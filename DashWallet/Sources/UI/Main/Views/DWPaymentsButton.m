//
//  Created by Andrew Podkovyrin
//  Copyright © 2019 Dash Core Group. All rights reserved.
//
//  Licensed under the MIT License (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//  https://opensource.org/licenses/MIT
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

/*
 WIP Info
 
 Using a single shape layer to animate transform from "v" to "x" leads to unpleasant animation
 between those paths. Almost the same problem: https://stackoverflow.com/q/9513082:
 
 > Animating the path of a shape layer is only guaranteed to work when you are animating from like to like. A rectangle is a sequence of lines, while an ellipse is a sequence of arcs (you can see the sequence generated by using CGPathApply), and as such the animation between them isn't guaranteed to look very good, or work well at all.
 >
 > To do this, you basically have to create an analog of a rectangle by using the same curves that you would use to create an ellipse, but with parameters that would cause the rendering to look like a rectangle. This shouldn't be too difficult (and again, you can use what you get from CGPathApply on the path created with CGPathAddEllipseInRect as a guide), but will likely require some tweaking to get right.
 
 That's why we're using two line segments and animate transformation from line to line.
 
 These functions below for historical purposes:
 
 static UIBezierPath *VIconPath(void) {
    UIBezierPath *bezierPath = [UIBezierPath bezierPath];
 
    // In (0, 0) coordinates:
    //    [bezierPath moveToPoint:CGPointMake(0, 11)];
    //    [bezierPath addLineToPoint:CGPointMake(10, 0)];
    //    [bezierPath addLineToPoint:CGPointMake(20, 11)];
 
    // Centered in (0, 0, 48, 48) rect:
    [bezierPath moveToPoint:CGPointMake(14, 29)];
    [bezierPath addLineToPoint:CGPointMake(24, 18)];
    [bezierPath addLineToPoint:CGPointMake(34, 29)];
 
    return bezierPath;
 }
 
 static UIBezierPath *XIconPath(void) {
    UIBezierPath *bezierPath = [UIBezierPath bezierPath];
 
    // In (0,0) coordinates:
    //    [bezierPath moveToPoint:CGPointMake(0, 0)];
    //    [bezierPath addLineToPoint:CGPointMake(16, 16)];
    //    [bezierPath moveToPoint:CGPointMake(0, 16)];
    //    [bezierPath addLineToPoint:CGPointMake(16, 0)];
 
    // Centered in (0, 0, 48, 48) rect:
    [bezierPath moveToPoint:CGPointMake(16, 16)];
    [bezierPath addLineToPoint:CGPointMake(32, 32)];
    [bezierPath moveToPoint:CGPointMake(16, 32)];
    [bezierPath addLineToPoint:CGPointMake(32, 16)];
 
    return bezierPath;
 }

 */

#import "DWPaymentsButton.h"

#import "DWAnimatedShapeLayer.h"
#import "DWUIKit.h"

NS_ASSUME_NONNULL_BEGIN

CGSize const DW_PAYMENTS_BUTTON_SIZE = {48.0, 48.0};

static DWAnimatedShapeLayer *SegmentLayer(void) {
    DWAnimatedShapeLayer *layer = [DWAnimatedShapeLayer layer];
    layer.strokeColor = [UIColor whiteColor].CGColor;
    layer.fillColor = [UIColor dw_dashBlueColor].CGColor;
    layer.lineWidth = 2.0;
    layer.lineCap = kCALineCapRound;
    layer.lineJoin = kCALineJoinRound;

    return layer;
}

static UIBezierPath *VFirstSegment(void) {
    UIBezierPath *bezierPath = [UIBezierPath bezierPath];

    // In (0, 0, 0, 0) coordinates:
    //    [bezierPath moveToPoint: CGPointMake(0, 11)];
    //    [bezierPath addLineToPoint: CGPointMake(10, 0)];

    // Centered in (0, 0, 48, 48) rect:
    [bezierPath moveToPoint:CGPointMake(14, 29)];
    [bezierPath addLineToPoint:CGPointMake(24, 18)];

    return bezierPath;
}

static UIBezierPath *VSecondSegment(void) {
    UIBezierPath *bezierPath = [UIBezierPath bezierPath];

    // In (0, 0, 0, 0) coordinates:
    //    [bezierPath moveToPoint: CGPointMake(10, 0)];
    //    [bezierPath addLineToPoint: CGPointMake(20, 11)];

    // Centered in (0, 0, 48, 48) rect:
    [bezierPath moveToPoint:CGPointMake(24, 18)];
    [bezierPath addLineToPoint:CGPointMake(34, 29)];

    return bezierPath;
}

static UIBezierPath *XFirstSegment(void) {
    UIBezierPath *bezierPath = [UIBezierPath bezierPath];

    // In (0, 0, 0, 0) coordinates:
    //    [bezierPath moveToPoint: CGPointMake(0, 0)];
    //    [bezierPath addLineToPoint: CGPointMake(16, 16)];

    // Centered in (0, 0, 48, 48) rect:
    [bezierPath moveToPoint:CGPointMake(16, 16)];
    [bezierPath addLineToPoint:CGPointMake(32, 32)];

    return bezierPath;
}

static UIBezierPath *XSecondSegment(void) {
    UIBezierPath *bezierPath = [UIBezierPath bezierPath];

    // In (0, 0, 0, 0) coordinates:
    //    [bezierPath moveToPoint: CGPointMake(0, 16)];
    //    [bezierPath addLineToPoint: CGPointMake(16, 0)];

    // Centered in (0, 0, 48, 48) rect:
    [bezierPath moveToPoint:CGPointMake(16, 32)];
    [bezierPath addLineToPoint:CGPointMake(32, 16)];

    return bezierPath;
}

@interface DWPaymentsButton ()

@property (readonly, strong, nonatomic) DWAnimatedShapeLayer *firstSegmentLayer;
@property (readonly, strong, nonatomic) DWAnimatedShapeLayer *secondSegmentLayer;

@end

@implementation DWPaymentsButton

- (instancetype)initWithFrame:(CGRect)frame {
    self = [super initWithFrame:frame];
    if (self) {
        [self paymentsButton_setup];
    }
    return self;
}

- (nullable instancetype)initWithCoder:(NSCoder *)coder {
    self = [super initWithCoder:coder];
    if (self) {
        [self paymentsButton_setup];
    }
    return self;
}

- (void)paymentsButton_setup {
    self.backgroundColor = [UIColor dw_dashBlueColor];
    self.layer.masksToBounds = YES;

    DWAnimatedShapeLayer *firstSegmentLayer = SegmentLayer();
    [self.layer addSublayer:firstSegmentLayer];
    _firstSegmentLayer = firstSegmentLayer;

    DWAnimatedShapeLayer *secondSegmentLayer = SegmentLayer();
    [self.layer addSublayer:secondSegmentLayer];
    _secondSegmentLayer = secondSegmentLayer;

    // Initial state
    firstSegmentLayer.path = VFirstSegment().CGPath;
    secondSegmentLayer.path = VSecondSegment().CGPath;
}

- (void)layoutSubviews {
    [super layoutSubviews];

    const CGFloat width = CGRectGetWidth(self.bounds);
    self.layer.cornerRadius = width / 2.0;

    self.firstSegmentLayer.frame = self.bounds;
    self.secondSegmentLayer.frame = self.bounds;
}

- (void)setOpened:(BOOL)opened {
    _opened = opened;

    if (opened) {
        [self animateLayer:self.firstSegmentLayer toPath:XFirstSegment() isSecond:NO];
        [self animateLayer:self.secondSegmentLayer toPath:XSecondSegment() isSecond:YES];
    }
    else {
        [self animateLayer:self.firstSegmentLayer toPath:VFirstSegment() isSecond:NO];
        [self animateLayer:self.secondSegmentLayer toPath:VSecondSegment() isSecond:YES];
    }
}

- (void)animateLayer:(DWAnimatedShapeLayer *)layer toPath:(UIBezierPath *)path isSecond:(BOOL)isSecond {
    NSString *const pathKey = @"path";
    NSString *const zRotationKey = @"transform.rotation.z";
    const CFTimeInterval pathDuration = 0.25;
    const CFTimeInterval rotationDuration = 0.2;

    CGPathRef pathRef = path.CGPath;

    CABasicAnimation *pathAnimation = [CABasicAnimation animationWithKeyPath:pathKey];
    pathAnimation.fromValue = [layer.presentationLayer valueForKey:pathKey];
    pathAnimation.toValue = (id)path.CGPath;
    pathAnimation.duration = pathDuration;
    pathAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];

    CASpringAnimation *springRotation = [CASpringAnimation animationWithKeyPath:zRotationKey];
    springRotation.toValue = @((isSecond ? -15.0 : 15.0) * M_PI / 180.0); // 15°
    springRotation.duration = rotationDuration;
    springRotation.initialVelocity = -12.0;
    springRotation.beginTime = pathDuration;
    springRotation.autoreverses = YES;

    CAAnimationGroup *animation = [CAAnimationGroup animation];
    animation.animations = @[ pathAnimation, springRotation ];
    animation.duration = pathDuration + rotationDuration;

    layer.path = pathRef;
    [layer addAnimation:animation forKey:@"dw_segment_animation"];
}

@end

NS_ASSUME_NONNULL_END
